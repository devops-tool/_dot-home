#!/usr/bin/env bash
set -o pipefail

# To-do:
# * learn to link .home/dot/**{!.inb?} files

############################################################

die()  { echo -e >&2 ".home ERROR:" "$@"; exit 1; }
warn() { echo -e >&2 ".home WARNING:" "$@"; }

save_ifs() { oldifs="$IFS"; IFS="$1"; }
restore_ifs() { IFS="$oldifs"; }

set_dest_target() {
    local src="$1"      # relative to ~/.home/
    # non-local outputs:
    # $dest             relative to ~/
    # $target           relative to $(dirname dest/)

    dest="${src#*/}"
    dest="${dest/#dot\//.}"
    [ "$dest" = dot ] && dest=.     # dest is the 'dot' directory itself (no /)

    local slashes="${dest//[^\/]/}"    # Leave only slashes...
    target="${slashes//\//../}.home/$src"
}

canonicalize_dots() {
    save_ifs '/'

    local -a output=()
    for component in $1; do
        case "$component" in
        '')     ;;
        .)      ;;
        ..)     if    [ "${#output[@]}" -eq 0 ] \
                   || [ "${output[${#output[@]} -1]}" = '..' ]
                then
                    output+=("$component")
                else
                    unset "output[${#output[@]} - 1]"
                fi
                ;;
        *)      output+=("$component");;
        esac
    done

    local leading_slash trailing_slash
    [ "${1:0:1}" = / ] && leading_slash=/
    [ "${1: -1}" = / ] && trailing_slash=/
    echo "$leading_slash${output[*]}$trailing_slash"

    restore_ifs
}

link_target() {
    local target="$(readlink "$1")"
    if [ "${target:0:1}" = / ]; then
        canonicalize_dots "$target"
    else
        canonicalize_dots "$(dirname "$1")/$target"
    fi
}

run_symlink_pass() {
    for module in *; do
        [[ "$module" =~ ^[A-Za-z0-9_-]+$ ]] || continue
        save_ifs $'\n'
        for src in $(find 2>/dev/null                           \
            "$module/bin" "$module/dot"                         \
            ! -regex '.*\.inb[0-9]'                             \
            | sort)
        do
            set_dest_target "$src"
            # check if dest is dangling link into .home
            if [ -L ../"$dest" ]; then
                # Remove dangling links into ~/.home/
                link_target="$(link_target $HOME/$dest)"
                [[ "$link_target" =~ ^$HOME/.home/ ]] \
                    && [ ! -e "$link_target" ] \
                    && rm -f ../"$dest"
            fi
            if [ -d "$src" ]; then
                mkdir -p "../$dest" 2>/dev/null || warn "Conflict: .home/$src/"
            elif [ -f "$src" ]; then
                [ "$(readlink "../$dest")" = "$target" ] && continue
                ln -s "$target" "../$dest" 2>/dev/null \
                    || warn "Conflict: .home/$src"
            else
                : # Ignore anything that's not a dir or file.
            fi
        done
        restore_ifs
    done
}

declare -a inb4_sorted
inb4_sort() {
    inb4_sorted=()
    while read line; do
        inb4_sorted+=("$line");
    done < <(
        for path in "$@"; do echo "${path: -1} $path"; done \
            | sort -n --stable \
            | sed -e 's/^..//' \
        )
}

inb4_cat() {
    inb4_sort "$@"
    echo '##### This file was generated by inb4.'
    for file in "${inb4_sorted[@]}"; do
        echo; echo "##### $file"
        cat "$file"
    done
}

inb4_check_file_conflicts() {
    local output
    while read output; do
        local     built=",inb4/$output"
        local installed="_inb4/$output"

        if [ ! -e "$installed" ]; then
            echo "$output"
        elif cmp -s "$built" "$installed"; then
            echo "$output"
        elif [ ! -e "$built" ]; then
            warn "$output has no previously built version to check"
        else
            warn "$output has been changed from version built by inb4"
        fi
    done
}

inb4check_has_run=false
declare -a inb4_outputs
run_inb4check_pass() {
    local oldifs="$IFS"; IFS=$'\n'
    inb4_outputs=($(
        find . -name '*.inb[0-9]' \
        | sed -e s,./[^/]*/,, -e 's,\.inb[0-9]$,,' \
        | sort -u \
        | inb4_check_file_conflicts
    ))
    IFS="$oldifs"
    inb4check_has_run=true
}

run_inb4build_pass() {
    $inb4check_has_run || {
        warn 'Must run inb4check pass before inb4build pass'
        return
    }
    local output
    for output in "${inb4_outputs[@]}"; do
        mkdir -p "$(dirname ",inb4/$output")" "$(dirname "_inb4/$output")"
        inb4_cat */"$output".inb[0-9] > ",inb4/$output"
        cp ",inb4/$output" "_inb4/$output"
    done
}

############################################################

passes=()
while [ -n "$1" ]; do case "$1" in
    --define-functions-only)    return 0; exit 0;;
    -p)                         passes+=("$2"); shift; shift;;
    *)                          die "Unknown argument: $1";;
esac; done
[ -z "$passes" ] && passes=(inb4check inb4build symlink)

cd "$HOME"/.home/ 2>/dev/null || die "Cannot change to $HOME/.home/."
for p in "${passes[@]}"; do
    run_${p}_pass
done
