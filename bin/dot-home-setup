#!/usr/bin/env bash
set -o pipefail

# To-do:
# * learn to link .home/dot/**{!.inb?} files

############################################################

die()  { echo -e >&2 ".home ERROR:" "$@"; exit 1; }
warn() { echo -e >&2 ".home WARNING:" "$@"; }

save_ifs() { oldifs="$IFS"; IFS="$1"; }
restore_ifs() { IFS="$oldifs"; }

set_dest_target() {
    local src="$1"      # relative to ~/.home/
    # non-local outputs:
    # $dest             relative to ~/
    # $target           relative to $(dirname dest/)

    dest="${src#*/}"
    dest="${dest/#dot\//.}"
    [ "$dest" = dot ] && dest=.     # dest is the 'dot' directory itself (no /)

    local slashes="${dest//[^\/]/}"    # Leave only slashes...
    target="${slashes//\//../}.home/$src"
}

canonicalize_dots() {
    save_ifs '/'

    local -a output=()
    for component in $1; do
        case "$component" in
        '')     ;;
        .)      ;;
        ..)     if    [ "${#output[@]}" -eq 0 ] \
                   || [ "${output[${#output[@]} -1]}" = '..' ]
                then
                    output+=("$component")
                else
                    unset "output[${#output[@]} - 1]"
                fi
                ;;
        *)      output+=("$component");;
        esac
    done

    local leading_slash trailing_slash
    [ "${1:0:1}" = / ] && leading_slash=/
    [ "${1: -1}" = / ] && trailing_slash=/
    echo "$leading_slash${output[*]}$trailing_slash"

    restore_ifs
}

link_target() {
    local target="$(readlink "$1")"
    if [ "${target:0:1}" = / ]; then
        canonicalize_dots "$target"
    else
        canonicalize_dots "$(dirname "$1")/$target"
    fi
}

symlinker() {
    for module in *; do
        [[ "$module" =~ ^[A-Za-z0-9_-]+$ ]] || continue
        save_ifs $'\n'
        for src in $(find 2>/dev/null                           \
            "$module/bin" "$module/dot"                         \
            ! -regex '.*\.inb[0-9]'                             \
            | sort)
        do
            set_dest_target "$src"
            # check if dest is dangling link into .home
            if [ -L ../"$dest" ]; then
                # Remove dangling links into ~/.home/
                link_target="$(link_target $HOME/$dest)"
                [[ "$link_target" =~ ^$HOME/.home/ ]] \
                    && [ ! -e "$link_target" ] \
                    && rm -f ../"$dest"
            fi
            if [ -d "$src" ]; then
                mkdir -p "../$dest" 2>/dev/null || warn "Conflict: .home/$src/"
            elif [ -f "$src" ]; then
                [ "$(readlink "../$dest")" = "$target" ] && continue
                ln -s "$target" "../$dest" 2>/dev/null \
                    || warn "Conflict: .home/$src"
            else
                : # Ignore anything that's not a dir or file.
            fi
        done
        restore_ifs
    done
}

############################################################

[ _"$1" = _--define-functions-only ] && { return 0; exit 0; }

cd "$HOME"/.home/ 2>/dev/null || die "Cannot change to $HOME/.home/."
symlinker
